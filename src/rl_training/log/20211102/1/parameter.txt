    class GraspEnv(py_environment.PyEnvironment):

    def __init__(self, input_image_size):
        self._action_spec = array_spec.BoundedArraySpec(shape=(), dtype=np.int32, minimum=0, maximum=5, name="action")

        self.input_image_size = input_image_size
        self._observation_spec = {  "grab_normal" : array_spec.BoundedArraySpec((self.input_image_size[0], self.input_image_size[1], 3), dtype = np.float32, minimum=0, maximum=255),
                                    "grab_approach" : array_spec.BoundedArraySpec((self.input_image_size[0], self.input_image_size[1], 3), dtype = np.float32, minimum=0, maximum=255),
                                    "grab_open" : array_spec.BoundedArraySpec((self.input_image_size[0], self.input_image_size[1], 3), dtype = np.float32, minimum=0, maximum=255)
                                    }

        self._state = { "grab_normal" : np.zeros((self.input_image_size[0], self.input_image_size[1], 3), np.float32),
                        "grab_approach" : np.zeros((self.input_image_size[0], self.input_image_size[1], 3), np.float32),
                        "grab_open" : np.zeros((self.input_image_size[0], self.input_image_size[1], 3), np.float32)
                        }
                        
        self._episode_ended = False

        self._reward = 0 
        self._step_counter = 0
        self._step_lengh = 50
        self._number_of_grab_pointClouds = 0
        self._number_of_finger_grab_pointClouds = 0
        self.pointLikelihoos_left_finger = 0
        self.pointLikelihoos_right_finger = 0
        self.apporachLikelihood = 0

        self.grab_normal_rgb_image = np.zeros((0,0,3), np.float32)
        self.grab_approach_rgb_image = np.zeros((0,0,3), np.float32)
        self.grab_open_rgb_image = np.zeros((0,0,3), np.float32)

        self.rotate_x = 0 
        self.rotate_y = 0 
        self.rotate_z = 0 

        # Create ROS subscriber for number of pointcloud in gripper working area (the reward of reinforcement learning agent...?)
        rospy.Subscriber("/Number_of_Grab_PointClouds", Int64, self.number_of_grab_pointClouds_callback)

        # Create ROS subscriber for mapping rgb image from gripper axis of normal vector (the state of reinforcement learning agent)
        rospy.Subscriber("/projected_image/grab_normal_rgb", Image, self.grab_normal_rgb_callback)

        # Create ROS subscriber for mapping rgb image from gripper axis of approach vector (the state of reinforcement learning agent)
        rospy.Subscriber("/projected_image/grab_approach_rgb", Image, self.grab_approach_rgb_callback)

        # Create ROS subscriber for mapping rgb image from gripper axis of open vector (the state of reinforcement learning agent)
        rospy.Subscriber("/projected_image/grab_open_rgb", Image, self.grab_open_rgb_callback)

        rospy.Subscriber("/Number_of_Finger_Grab_PointClouds", Int64, self.finger_point_callback)

        rospy.Subscriber("/PointLikelihoos/Left_Finger", Float64, self.pointLikelihoos_left_finger_callback)

        rospy.Subscriber("/PointLikelihoos/Right_Finger", Float64, self.pointLikelihoos_right_finger_callback)

        rospy.Subscriber("/ApporachLikelihood", Float64, self.apporachLikelihood_callback)
    
    def apporachLikelihood_callback(self, num):
        self.apporachLikelihood = num.data

    def pointLikelihoos_left_finger_callback(self, num):
        self.pointLikelihoos_left_finger = num.data
        # print("self.pointLikelihoos_left_finger ", self.pointLikelihoos_left_finger)

    def pointLikelihoos_right_finger_callback(self, num):
        self.pointLikelihoos_right_finger = num.data
        # print("self.pointLikelihoos_right_finger ", self.pointLikelihoos_right_finger)

    def finger_point_callback(self, num):
        self._number_of_finger_grab_pointClouds = num.data
        # print("self._number_of_finger_grab_pointClouds ", self._number_of_finger_grab_pointClouds)

    def number_of_grab_pointClouds_callback(self, num):
        self._number_of_grab_pointClouds = num.data
        # print("self.number_of_grab_pointClouds: ", self._number_of_grab_pointClouds)

    def grab_normal_rgb_callback(self, image):
        try:
            self.grab_normal_rgb_image = grab_normal_rgb_bridge.imgmsg_to_cv2(image, "bgr8").astype(np.float32)/255
            # cv2.namedWindow('grab_normal_rgb_image', cv2.WINDOW_NORMAL)
            # cv2.imshow('grab_normal_rgb_image', self.grab_normal_rgb_image)
            # cv2.waitKey(1)
            # cv2.imwrite("/home/luca-home-ubuntu20/code/RVP_GGCNN/grab_normal.jpg", self.grab_normal_rgb_image)
            # print("self.grab_normal_rgb_image: ", self.grab_normal_rgb_image)
        except CvBridgeError as e:
            print(e)

    def grab_approach_rgb_callback(self, image):
        try:
            self.grab_approach_rgb_image = grab_approach_rgb_bridge.imgmsg_to_cv2(image, "bgr8").astype(np.float32)/255
            # cv2.namedWindow('grab_approach_rgb_image', cv2.WINDOW_NORMAL)
            # cv2.imshow('grab_approach_rgb_image', grab_approach_rgb_image)
            # cv2.waitKey(1)
        except CvBridgeError as e:
            print(e)

    def grab_open_rgb_callback(self, image):
        try:
            self.grab_open_rgb_image = grab_open_rgb_bridge.imgmsg_to_cv2(image, "bgr8").astype(np.float32)/255
            # cv2.namedWindow('grab_open_rgb_image', cv2.WINDOW_NORMAL)
            # cv2.imshow('grab_open_rgb_image', grab_open_rgb_image)
            # cv2.waitKey(1)
        except CvBridgeError as e:
            print(e)

    def action_spec(self):
        return self._action_spec
    
    def observation_spec(self):
        return self._observation_spec
    
    def _reset(self):
        # self._state = { "grab_normal" : np.zeros((self.input_image_size[0], self.input_image_size[1], 3), np.float32),
        #                 "grab_approach" : np.zeros((self.input_image_size[0], self.input_image_size[1], 3), np.float32),
        #                 "grab_open" : np.zeros((self.input_image_size[0], self.input_image_size[1], 3), np.float32)
        #                 }
        self._update_ROS_data()
        self._reward = 0 
        self._episode_ended = False
        self.rotate_x = 0 
        self.rotate_y = 0 
        self.rotate_z = 0 
        return ts.restart(self._state)
    
    def _rotate_grasp(self, rotate_axis):
        
        rotation = AngleAxis_rotation_msg()
        rotation.x = self.rotate_x
        rotation.y = self.rotate_y
        rotation.z = self.rotate_z

        # 5 degree
        rotation_angle = math.pi/36

        if rotate_axis not in ["x", "-x", "y", "-y", "z", "-z"]:

            print("rotate_axis must in [x, y, z ,-x, -y, -z]!!")
        
        else:
            if rotate_axis == "x":

                self.rotate_x = self.rotate_x + rotation_angle
                
                rotation.x = self.rotate_x

            elif rotate_axis == "-x":

                self.rotate_x = self.rotate_x + rotation_angle

                rotation.x = -1 * self.rotate_x

            elif rotate_axis == "y":

                self.rotate_y = self.rotate_y + rotation_angle

                rotation.y = self.rotate_y 

            elif rotate_axis == "-y":

                self.rotate_y = self.rotate_y + rotation_angle

                rotation.y = -1 * self.rotate_y 

            elif rotate_axis == "z":

                self.rotate_z = self.rotate_z + rotation_angle

                rotation.z = self.rotate_z

            elif rotate_axis == "-z":

                self.rotate_z = self.rotate_z + rotation_angle

                rotation.z = -1 * self.rotate_z
            else:
                print("something wrong..")

            pub_AngleAxisRotation.publish(rotation)



    def _update_ROS_data(self):
        self._state["grab_normal"] = self.grab_normal_rgb_image
        self._state["grab_approach"] = self.grab_approach_rgb_image
        self._state["grab_open"] = self.grab_open_rgb_image

    def _update_reward(self):
        self._reward = self._number_of_grab_pointClouds - 70 - self._step_counter - self._number_of_finger_grab_pointClouds - self.pointLikelihoos_right_finger - self.pointLikelihoos_left_finger

    def _step(self, action):

        self._update_ROS_data()
        self._update_reward()

        if self._episode_ended:
            return self.reset()
        
        if action == 0:

            self._rotate_grasp("x")

        elif action ==1:

            self._rotate_grasp("-x")

        elif action ==2:

            self._rotate_grasp("y")

        elif action ==3:

            self._rotate_grasp("-y")

        elif action ==4:

            self._rotate_grasp("z")

        elif action ==5:

            self._rotate_grasp("-z")

        else:
            self._episode_ended = True
        
        self._step_counter = self._step_counter +1
        
        if self._step_counter > self._step_lengh:
            self._episode_ended = True
            self._step_counter = 0
            return ts.termination(self._state, self._reward)

        else:
            return ts.transition(self._state, self._reward, discount=1.0)
